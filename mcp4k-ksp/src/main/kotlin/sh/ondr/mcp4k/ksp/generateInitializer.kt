package sh.ondr.mcp4k.ksp

import com.google.devtools.ksp.processing.Dependencies

fun Mcp4kProcessor.generateInitializer() {
	val name = if (isTest) "Mcp4kTestInitializer" else "Mcp4kInitializer"
	val mcp4kInitializerPackage = "$pkg.generated.initializer"
	val file = codeGenerator.createNewFile(
		dependencies = Dependencies(
			aggregating = true,
			sources = tools.map { it.originatingFile }.toTypedArray(),
		),
		packageName = mcp4kInitializerPackage,
		fileName = name,
	)

	val code = buildString {
		appendLine("// Generated by mcp4k")
		appendLine("package $mcp4kInitializerPackage")
		appendLine()
		appendLine("import sh.ondr.mcp4k.runtime.core.mcpPromptParams")
		appendLine("import sh.ondr.mcp4k.runtime.core.mcpPromptHandlers")
		appendLine("import sh.ondr.mcp4k.runtime.core.mcpToolParams")
		appendLine("import sh.ondr.mcp4k.runtime.core.mcpToolHandlers")
		if (tools.isNotEmpty()) {
			appendLine("import $mcp4kHandlersPackage.*")
			appendLine("import $mcp4kParamsPackage.*")
		}
		appendLine("import kotlin.reflect.KClass")
		appendLine()
		appendLine("object $name {")
		appendLine("  init {")

		for (tool in tools) {
			val handlerClassName = tool.functionName.replaceFirstChar { it.uppercase() } + "McpToolHandler"
			val paramsClassName = tool.paramsClassName
			appendLine("    // Register '${tool.functionName}'")
			appendLine("    mcpToolParams[\"${tool.functionName}\"] = $paramsClassName::class")
			appendLine("    mcpToolHandlers[\"${tool.functionName}\"] = $handlerClassName()")
		}

		for (prompt in prompts) {
			val handlerClassName = prompt.functionName.replaceFirstChar { it.uppercase() } + "McpPromptHandler"
			val paramsClassName = prompt.paramsClassName
			appendLine("    // Register '${prompt.functionName}'")
			appendLine("    mcpPromptParams[\"${prompt.functionName}\"] = $paramsClassName::class")
			appendLine("    mcpPromptHandlers[\"${prompt.functionName}\"] = $handlerClassName()")
		}

		appendLine("  }")
		appendLine("}")
	}

	file.write(code.toByteArray())
	file.close()
}
