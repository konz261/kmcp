package sh.ondr.kmcp.ksp

import com.google.devtools.ksp.processing.Dependencies

// TODO clean this up
internal fun KmcpProcessor.generateInitializer() {
	val fileName = "KmcpGeneratedInitializer"
	// Combine tool and prompt originating files to ensure all dependencies are accounted for.
	val allFiles = (collectedTools.flatMap { it.originatingFiles } + collectedPrompts.flatMap { it.originatingFiles })
		.distinct()
		.toTypedArray()

	val file = codeGenerator.createNewFile(
		dependencies = Dependencies(aggregating = true, sources = allFiles),
		packageName = generatedPkg,
		fileName = fileName,
	)

	val code = buildString {
		appendLine("// Generated by KMCP")
		appendLine("package $generatedPkg")
		appendLine()
		appendLine("import sh.ondr.kmcp.runtime.core.mcpToolInfos")
		appendLine("import sh.ondr.kmcp.runtime.core.mcpToolHandlers")
		appendLine("import sh.ondr.kmcp.runtime.core.mcpPromptInfos")
		appendLine("import sh.ondr.kmcp.runtime.core.mcpPromptHandlers")
		appendLine("import sh.ondr.kmcp.schema.tools.ToolInfo")
		appendLine("import sh.ondr.jsonschema.jsonSchema")
		appendLine("import sh.ondr.kmcp.schema.prompts.PromptInfo")
		appendLine("import sh.ondr.kmcp.schema.prompts.PromptArgument")
		appendLine()
		appendLine("object KmcpGeneratedInitializer {")
		appendLine("  init {")
		// Register tools first
		for (helper in collectedTools) {
			val paramsClassName = "KmcpGenerated${helper.functionName.replaceFirstChar { it.uppercaseChar() }}ToolParams"
			val handlerClassName = "KmcpGenerated${helper.functionName.replaceFirstChar { it.uppercaseChar() }}ToolHandler"
			val toolName = helper.functionName

			appendLine("    // Register tool '$toolName'")
			val toolDescription = if (helper.description != null) "\"${helper.description}\"" else "null"
			appendLine("    val ${toolName}ToolInfo = ToolInfo(")
			appendLine("      name = \"$toolName\",")
			appendLine("      description = $toolDescription,")
			appendLine("      inputSchema = jsonSchema<$paramsClassName>()")
			appendLine("    )")
			appendLine("    mcpToolInfos[\"$toolName\"] = ${toolName}ToolInfo")
			appendLine("    mcpToolHandlers[\"$toolName\"] = $handlerClassName()")
			appendLine()
		}

		// Register prompts
		for (helper in collectedPrompts) {
			val promptName = helper.functionName
			val handlerClassName = "KmcpGenerated${helper.functionName.replaceFirstChar { it.uppercaseChar() }}PromptHandler"

			appendLine("    // Register prompt '$promptName'")
			val promptDescription = if (helper.description != null) "\"${helper.description}\"" else "null"

			// Each parameter maps to a PromptArgument, using the param's name and description if available.
			// required = true if it's required, false otherwise.
			// We'll inline the arguments array as a listOf(...)
			appendLine("    val ${promptName}Arguments = listOf(")
			helper.params.forEachIndexed { index, param ->
				val argComma = if (index == helper.params.size - 1) "" else ", "
				val argDesc = param.description?.let { "\"$it\"" } ?: "null"
				append("PromptArgument(name = \"${param.name}\", description = $argDesc, required = ${param.isRequired})$argComma")
			}
			appendLine(")")

			appendLine("    val ${promptName}PromptInfo = PromptInfo(")
			appendLine("      name = \"$promptName\",")
			appendLine("      description = $promptDescription,")
			appendLine("      arguments = ${promptName}Arguments")
			appendLine("    )")
			appendLine("    mcpPromptInfos[\"$promptName\"] = ${promptName}PromptInfo")
			appendLine("    mcpPromptHandlers[\"$promptName\"] = $handlerClassName()")
			appendLine()
		}

		appendLine("  }")
		appendLine("}")
	}

	file.write(code.toByteArray())
	file.close()
}
