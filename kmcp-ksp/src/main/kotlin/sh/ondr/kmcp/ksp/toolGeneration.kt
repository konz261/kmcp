package sh.ondr.kmcp.ksp

import com.google.devtools.ksp.processing.Dependencies

internal fun KmcpProcessor.generateToolFiles() {
	generateToolParamsFile()
	generateToolHandlersFile()
}

private fun KmcpProcessor.generateToolParamsFile() {
	val fileName = "KmcpGeneratedToolParams"
	val allFiles = collectedTools.flatMap { it.originatingFiles }.distinct().toTypedArray()
	val file = codeGenerator.createNewFile(
		dependencies = Dependencies(aggregating = true, sources = allFiles),
		packageName = generatedPkg,
		fileName = fileName,
	)

	val code = buildString {
		appendLine("// Generated by KMCP")
		appendLine("package $generatedPkg")
		appendLine()
		appendLine("import kotlinx.serialization.Serializable")
		appendLine()

		for (helper in collectedTools) {
			val paramsClassName = "KmcpGenerated${helper.functionName.replaceFirstChar { it.uppercaseChar() }}ToolParams"
			appendLine("@Serializable")
			append("data class $paramsClassName(\n")
			helper.params.forEachIndexed { index, p ->
				val comma = if (index == helper.params.size - 1) "" else ","
				if (!p.hasDefault && !p.isNullable) {
					append("    val ${p.name}: ${p.fqnType}$comma\n")
				} else {
					append("    val ${p.name}: ${p.fqnType}? = null$comma\n")
				}
			}
			appendLine(")")
			appendLine()
		}
	}

	file.write(code.toByteArray())
	file.close()
}

private fun KmcpProcessor.generateToolHandlersFile() {
	val fileName = "KmcpGeneratedToolHandlers"
	val allFiles = collectedTools.flatMap { it.originatingFiles }.distinct().toTypedArray()
	val file = codeGenerator.createNewFile(
		dependencies = Dependencies(aggregating = true, sources = allFiles),
		packageName = generatedPkg,
		fileName = fileName,
	)

	val code = buildString {
		appendLine("// Generated by KMCP")
		appendLine("package $generatedPkg")
		appendLine()
		appendLine("import kotlinx.serialization.json.JsonObject")
		appendLine("import kotlinx.serialization.json.decodeFromJsonElement")
		appendLine("import sh.ondr.kmcp.runtime.core.kmcpJson")
		appendLine("import sh.ondr.kmcp.schema.tools.CallToolResult")
		appendLine("import sh.ondr.kmcp.schema.content.ToolContent")
		appendLine("import sh.ondr.kmcp.runtime.tools.ToolHandler")
		appendLine("import sh.ondr.kmcp.runtime.error.MissingRequiredArgumentException")
		appendLine("import sh.ondr.kmcp.runtime.error.UnknownArgumentException")
		appendLine()

		for (helper in collectedTools) {
			val handlerClassName = "KmcpGenerated${helper.functionName.replaceFirstChar { it.uppercaseChar() }}ToolHandler"
			val paramsClassName = "KmcpGenerated${helper.functionName.replaceFirstChar { it.uppercaseChar() }}ToolParams"

			// Gather parameter names
			val paramNames = helper.params.map { it.name }.joinToString { "\"$it\"" }

			appendLine("class $handlerClassName : ToolHandler {")
			appendLine("    private val knownParams = setOf($paramNames)")
			appendLine()
			appendLine("    override fun call(params: JsonObject): CallToolResult {")
			appendLine("        val unknownKeys = params.keys - knownParams")
			appendLine("        if (unknownKeys.isNotEmpty()) {")
			appendLine(
				"            throw UnknownArgumentException(\"Unknown argument '\${unknownKeys.first()}' for tool '${helper.functionName}'\")",
			)
			appendLine("        }")
			appendLine()
			// Check required parameters
			val requiredParams = helper.params.filter { it.isRequired }.map { it.name }
			if (requiredParams.isNotEmpty()) {
				appendLine("        // Check required parameters")
				for (reqParam in requiredParams) {
					appendLine("        if (!params.containsKey(\"$reqParam\")) {")
					appendLine("            throw MissingRequiredArgumentException(\"Missing required argument '$reqParam'\")")
					appendLine("        }")
				}
			}
			appendLine()
			appendLine("        val obj = kmcpJson.decodeFromJsonElement($paramsClassName.serializer(), params)")
			appendLine("        val result = ${generateInvocationCode(helper, 2)}")
			appendLine("        return CallToolResult(listOf(result))")
			appendLine("    }")
			appendLine("}")
			appendLine()
		}
	}

	file.write(code.toByteArray())
	file.close()
}

internal fun KmcpProcessor.generateInvocationCode(
	helper: ToolHelper,
	level: Int,
): String {
	val defaultParams = helper.params.filter { it.hasDefault }
	val requiredParams = helper.params.filter { !it.hasDefault }
	return generateToolOptionalChain(helper, requiredParams, defaultParams, level)
}

private fun KmcpProcessor.generateToolOptionalChain(
	helper: ToolHelper,
	requiredParams: List<ParamInfo>,
	defaultParams: List<ParamInfo>,
	level: Int,
): String {
	if (defaultParams.isEmpty()) {
		return callToolFunction(helper.fqName, requiredParams, emptyList(), level)
	}

	val firstOptional = defaultParams.first()
	val remaining = defaultParams.drop(1)
	val indent = " ".repeat(level * 4)

	return buildString {
		appendLine("${indent}if (params.containsKey(\"${firstOptional.name}\")) {")
		val ifBranch = generateToolOptionalChain(helper, requiredParams + firstOptional, remaining, level + 1)
		appendLine(ifBranch)
		appendLine("$indent} else {")
		val elseBranch = generateToolOptionalChain(helper, requiredParams, remaining, level + 1)
		appendLine(elseBranch)
		appendLine("$indent}")
	}
}

private fun KmcpProcessor.callToolFunction(
	fqFunctionName: String,
	requiredParams: List<ParamInfo>,
	optionalParams: List<ParamInfo>,
	level: Int,
): String {
	val indent = " ".repeat(level * 4)
	val allParams = requiredParams + optionalParams
	val args = allParams.joinToString(",\n$indent    ") { param ->
		val suffix = if (param.hasDefault && !param.isNullable) "!!" else ""
		"${param.name} = obj.${param.name}$suffix"
	}
	return buildString {
		appendLine("$indent$fqFunctionName(")
		if (allParams.isNotEmpty()) {
			appendLine("$indent    $args")
		}
		append("$indent)")
	}
}
