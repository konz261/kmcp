package sh.ondr.kmcp.ksp.tools

import com.google.devtools.ksp.processing.Dependencies
import sh.ondr.kmcp.ksp.KmcpProcessor
import sh.ondr.kmcp.ksp.ParamInfo

fun KmcpProcessor.generateToolHandlersFile() {
	val fileName = "KmcpGeneratedToolHandlers"
	val file = codeGenerator.createNewFile(
		dependencies = Dependencies(
			aggregating = true,
			sources = tools.map { it.originatingFile }.toTypedArray(),
		),
		packageName = kmcpHandlersPackage,
		fileName = fileName,
	)

	val code = buildString {
		appendLine("// Generated by kmcp")
		appendLine("package $kmcpHandlersPackage")
		appendLine()
		appendLine("import kotlinx.serialization.json.JsonObject")
		appendLine("import kotlinx.serialization.json.decodeFromJsonElement")
		appendLine("import sh.ondr.kmcp.runtime.core.mcpJson")
		appendLine("import sh.ondr.kmcp.runtime.tools.McpToolHandler")
		appendLine("import sh.ondr.kmcp.runtime.error.MissingRequiredArgumentException")
		appendLine("import sh.ondr.kmcp.runtime.error.UnknownArgumentException")
		appendLine("import sh.ondr.kmcp.schema.tools.CallToolResult")
		appendLine()

		for (tool in tools) {
			val handlerClassName = tool.functionName.replaceFirstChar { it.uppercase() } + "McpToolHandler"
			val fqParamsClass = "$kmcpParamsPackage.${tool.paramsClassName}"

			// Collect known parameter names
			val knownParams = tool.params.joinToString { "\"${it.name}\"" }

			// Collect strictly required parameters (no default, not nullable):
			val requiredParams = tool.params.filter { it.isRequired }

			appendLine("class $handlerClassName : McpToolHandler {")
			appendLine("  private val knownParams = setOf($knownParams)")
			appendLine()
			appendLine("  override suspend fun call(params: JsonObject): CallToolResult {")
			appendLine("    val unknownKeys = params.keys - knownParams")
			appendLine("    if (unknownKeys.isNotEmpty()) {")
			appendLine(
				"      throw UnknownArgumentException(\"Unknown argument '\${unknownKeys.first()}' for tool '${tool.functionName}'\")",
			)
			appendLine("    }")
			appendLine()

			// Check for missing required parameters
			if (requiredParams.isNotEmpty()) {
				appendLine("    // Check required parameters")
				for (reqParam in requiredParams) {
					appendLine("    if (!params.containsKey(\"${reqParam.name}\")) {")
					appendLine("      throw MissingRequiredArgumentException(\"Missing required argument '${reqParam.name}'\")")
					appendLine("    }")
				}
				appendLine()
			}

			// Decode into param class (which might have nulls for optional fields)
			appendLine("    val obj = mcpJson.decodeFromJsonElement($fqParamsClass.serializer(), params)")
			appendLine()

			// Generate function call with optional-branching for default-having params
			appendLine("    val result =")
			appendLine(generateInvocationCode(tool, 3))
			appendLine("    return CallToolResult(listOf(result))")
			appendLine("  }")
			appendLine("}")
			appendLine()
		}
	}

	file.write(code.toByteArray())
	file.close()
}

private fun KmcpProcessor.generateInvocationCode(
	toolMeta: ToolMeta,
	indentLevel: Int = 2,
): String {
	val fqFunctionName = toolMeta.fqName

	// "branchingParams" are those that have a default => we might skip them if absent
	val branchingParams = toolMeta.params.filter { it.hasDefault }

	// "alwaysParams" are all others => we always pass them in the function call
	val alwaysParams = toolMeta.params.filter { !it.hasDefault }

	return generateToolOptionalChain(
		fqFunctionName = fqFunctionName,
		alwaysParams = alwaysParams,
		defaultParams = branchingParams,
		indentLevel = indentLevel,
	)
}

private fun KmcpProcessor.generateToolOptionalChain(
	fqFunctionName: String,
	alwaysParams: List<ParamInfo>,
	defaultParams: List<ParamInfo>,
	indentLevel: Int,
): String {
	// Base case: if no more default-having params, just call the function with [alwaysParams].
	if (defaultParams.isEmpty()) {
		return callToolFunction(fqFunctionName, alwaysParams, emptyList(), indentLevel)
	}
	val firstOpt = defaultParams.first()
	val remainingOpts = defaultParams.drop(1)
	val indent = " ".repeat(indentLevel * 2)

	return buildString {
		appendLine("${indent}if (params.containsKey(\"${firstOpt.name}\")) {")
		// If present, treat it like we must pass it
		val ifBranch = generateToolOptionalChain(
			fqFunctionName = fqFunctionName,
			alwaysParams = alwaysParams + firstOpt,
			defaultParams = remainingOpts,
			indentLevel = indentLevel + 1,
		)
		appendLine(ifBranch)
		appendLine("$indent} else {")
		// If absent, skip it so the function call uses its default
		val elseBranch = generateToolOptionalChain(
			fqFunctionName = fqFunctionName,
			alwaysParams = alwaysParams, // not adding firstOpt
			defaultParams = remainingOpts,
			indentLevel = indentLevel + 1,
		)
		appendLine(elseBranch)
		appendLine("$indent}")
	}
}

private fun KmcpProcessor.callToolFunction(
	fqFunctionName: String,
	alwaysParams: List<ParamInfo>,
	optionalParams: List<ParamInfo>,
	indentLevel: Int,
): String {
	val indent = " ".repeat(indentLevel * 2)
	val allParams = alwaysParams + optionalParams

	// Each parameter becomes "name = obj.name" (+ "!!" if it hasDefault && not nullable)
	val args = allParams.joinToString(",\n$indent  ") { param ->
		// If param.hasDefault && !param.isNullable => we do "!!" to guarantee non-null
		val maybeBang = if (param.hasDefault && !param.isNullable) "!!" else ""
		"${param.name} = obj.${param.name}$maybeBang"
	}

	return buildString {
		appendLine("$indent$fqFunctionName(")
		if (allParams.isNotEmpty()) {
			appendLine("$indent  $args")
		}
		append("$indent)")
	}
}
